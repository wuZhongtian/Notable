# 前端性能优化

## 前期铺垫

- web前端的开发与部署过程
  - 用户使用浏览器，借助网址向服务器获取【动态的、增量式】的静态资源
  - 
- <img src="C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20211130230533113.png" alt="image-20211130230533113" style="zoom:50%;" />



- http请求的过程【深入理解http请求过程，是前端性能优化的核心】

  - 用户输入url ，浏览器解析后发送到DNS服务器，查询ip地址【DNS缓存，降低dns查询的时间？】

  - 借助基础网络，传输到对应的服务器【使用CDN请求静态资源，解决网络缓存、线路选择等问题，但默认携带的cookie是一种浪费，不同的cdn域名可以解决；但cdn无法作为接口】

  - 服务器接收到请求后，进行请求的分发处理Contorller

    - Model层，进行数据交互，读取数据库，获取数据
    - 最后将渲染好的页面通过View，返会给网络--浏览器

  - 浏览器接受数据【减少http请求的次数和大小？】

    - rander过程，浏览器将服务器返回的数据(html/css/js...)进行渲染【服务器端渲染？】

    - 浏览器生成DOM和BOM树，在进行css渲染，然后再去执行js相关的代码【渲染过程的优化？】

- ![image-20211130230829988](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20211130230829988.png)





## 资源的合并与压缩

**作用点：借助文件的合并减少http请求次数；借助文件压缩，减少请求文件的大小**

### html压缩

- 压缩在文本文件中有意义，但在HTML中不显示的字符，包括空格、制表符、换行符等，还有一些其他意义的字符，如：HTML注释也可以被压缩
- HTML压缩的效果不是很明显，但对于大量用户访问的网页来说，每kb的流量都不容忽视

#### html压缩方式

- 使用网站在线压缩，适合初学者（但一般不用，使用webpack...）
- node.js 提供了 `html-minifier`工具（可以进行很多的配置，具有可扩展性）
- 后端模板引擎渲染压缩（会增加服务端的计算量）

### css压缩

- 使用在线网站进行压缩
- 使用`html-minifier`库对html中的css进行压缩
- 使用`clean-css`库对css进行压缩

### js压缩与混乱

- 作用：无效字符的删除、剔除注释、代码语义的缩减和优化、代码保护(降低可读性)
- 方法：
  - 使用网站在线压缩
  - 使用`html-minifier`配置，对js进行压缩
  - 使用`uglifyjs2`对js进行压缩【】

### 文件合并

- 不合并存在的问题

  - 文件与文件之间有插入的上行请求，增加了N-1个网络延迟

  - 受丢包影响更为严重

  - 经过代理服务器时可能会被断开

    ![image-20211201103045973](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20211201103045973.png)

- 合并后的问题

  - 首屏渲染问题，合并后文件变大，首屏渲染可能减慢，需要适当分开
  - 缓存失效问题，任一文件的改动，会导致文件缓存大面积失效的问题

- 文件合并的建议

  - 公共库合并，对长期不经常改动的内合并
  - 不同页面的合并，对于单页应用，只加载当前页面，分别打包。
  - 见机行事，随机应变。

- 文件合并方法

  - 使用在线网站进行
  - 使用node.js实现文件合并，多种多样的库，自行挑选



### 操作流程

#### 在线压缩工具

- 有一定的限制，可能不支持部分文件格式的压缩
- 分别手动对原生代码进行压缩
- 在js压缩过程中，需要手动根据依赖关系压缩后再合并
- ![image-20211201105304024](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20211201105304024.png)

#### 构建工具的优点

- 对于大量的文件可以进行高效快速的构建
- 具有良好的可扩展性
- 可根据配置进行定制化的设置

#### webpack构建工具(使用再学习)

#### fis3构建工具(使用再学习)

- 流程：
  - 单文件编译过程，形成完整的结构
  - 打包，依据源文件的内容，进行压缩和混乱



![image-20211201105540261](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20211201105540261.png)





## 图片相关优化

**使用参考：文件大小、色彩的丰富度  根据不同场景进行选择**

### 类型分类

#### JPG图片- 有损压缩

- 情景：大部分**不需要透明图片**的业务场景
- 原始的数据与实际jpg压缩后的数据是不同的
- 但大多数jpg压缩并不影响肉眼观察
- 可能不支持透明，但实际使用大都可以透明

#### png8/png24/png32

- 情景：大部分需要**透明图片**的业务场景
- png8：256色+支持透明，
  - 内部其实是一个颜色的索引表，每个颜色就是2^8的索引值，因此会小很多
  - 适用于颜色变化不特别丰富的图片
  - 缺点：支持的颜色比较少，不适合颜色丰富且相近的图片
- png24：2^24色+不支持透明
  - 每一个索引值是png8的三倍
- png32：2^24色+支持透明
  - 相比于png24，增加了8位，用于支持透明

#### webp压缩程度更好，再ios和webview有兼容性问题

- 压缩程度更好，建议安卓全部使用

#### svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景

- 情景：图片样式相对简单的业务场景
- 例如 icon库，或者其他库....

#### gif 支持动画



### 图片压缩

本质：针对图片真实情况，舍弃一些相对无关紧要的色彩信息

#### css雪碧图

- 把网站的一些图片合并到一张图片，减少网站的HTTP请求数量
- 缺点：当图片文件较大时，可能导致图片的显示存在延迟的问题
- 一般使用在PC端，对性能要求较高
- 需要手动将图片合并，一定的ps基础

#### Image inline

- 将图片的内容内嵌到html中，减少网站的http请求数量
- 适合大小较小的图片，建议8kb以下做inline image使用
- 特点：导致页面文件变大，但减少了一次http请求
- ![image-20211213162118143](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20211213162118143.png)

#### svg矢量图

- 使用svg标签进行矢量图的绘制
- 使用iconfont解决icon问题
- 优点：速度和大小都会有很好的优化
- 学习：w3c

#### webp

- 优势：具有更优的图像数据压缩算法，能带来更小的体积，拥有无差别的图像质量
- 具备无损和有损的压缩模式、Alpha透明、动画特性
- 再PNG和JPEG上的转哈效果都非常优秀、稳定和统一

### 转换方法

#### 格式转换

- [TinyPNG – Compress WebP, PNG and JPEG images intelligently](https://tinypng.com/)
- [智图_图片压缩在线工具_在线制作webp (isux.us)](https://zhitu.isux.us/)
- [Sprite Cow 雪碧图制作 - Generate CSS for sprite sheets](http://www.spritecow.com/)
- [SVG 教程 (w3school.com.cn)](https://www.w3school.com.cn/svg/index.asp)
- 图片格式的降级：兼容性服务，如果不支持更好的webp格式，自动转化为jpg格式(淘宝网)
- 转换方法
  - 手动更改转换
  - 使用webpack 或者 fis3 等其他自动化工具，进行插件配置还能控制压缩率
  - 后端服务自动转换

![image-20211213204333298](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20211213204333298.png)



## css和js的装载与执行

- 学习目标：
  1. 理解浏览器端 html、css、js的加载过程
  2. 结合 chrome 的能力学习掌握加载过程中的优化点
- 渲染的过程
  1. 拿到html文件后渲染为DOM树
     - HTML渲染特点
     - 词法分析，由上至下顺序执行生成DOM，
     - 多种资源的加载是并发进行加载的(受浏览器对单个域名并发请求限制)，因此一个网站常使用多个cdn服务
     - 是否阻塞：css加载阻塞js加载？js加载阻塞js执行？
       - css 在head中阻塞页面的渲染，当css加载完再渲染html(推荐)
       - css阻塞js的执行，因为js的执行可能操作css的内容
       - css不阻塞外部脚本的加载，并发加载
       - 直接引入的js阻塞页面的渲染，存在js操作dom时，影响dom加载
       - js不阻塞资源的加载（有一个预先扫描器，不执行先加载）
       - js顺序执行，阻塞后续js逻辑的执行
     - 依赖关系：css资源加载过慢时，出现屏闪问题(等完全渲染完后再显示)
     - 引入方式：
       - css：link 和 @import
       - js：script 和 路由动态引入 和 和 
  2. 再根据css样式生成CSSOM树
  3. 将两者合并渲染为页面

![image-20211213211431367](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20211213211431367.png)



## 

## 第五章



## CSS

- 使用`translate3d`而不是`translate`手动开启GPU渲染引擎



## JS

- 尽可能避免污染全局变量，全局声明的变量不会被垃圾回收机制回收
- 局部变量在代码调用结束之后，就会释放对应的内存空间，提高代码性能
